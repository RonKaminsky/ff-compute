# Developer Overview

The demonstration.jl script initializes various variables and then reads the formula database. It then enters an infinite loop which repeatedly generates a large random number (the "target number") with "target_digits" digits and tries to generate a Friedman formula for it.

* The Friedman formula generation algorithm consists of up to three stages.

  * In the first stage, a long formula of the form: ((...(quotient * formula_1 + remainder_1) * formula_2 + remainder_2) + ... ) * formula_n + remainder_n) is generated. This formula should have significantly less digits than the the target number, because of the work expended searching over many more than 10^5 formulas which contain 5 digits or less. The digit histogram of that long formula could already be majorized by the digit histogram of the target number (i.e., for every digit i, the frequency of i in the target number is greater or equal to the frequency in the formula). In that case, it is almost certain that the unused digits can be absorbed (see "absorb.jl"), and we have already found a Friedman formula. It is more likely that this is not the case, and the algorithm proceeds to the next stage.

  * In the second stage, the first of possibly two cleanup stages, the numbers of the formula are sorted in descending order, and for each number the formula database is again exhaustively searched for the formula which best decreases the "digit disparity", that is, the total excess frequency of digits in the formula compared to the frequencies in the target number. The function which does this is cleanup_rpsr(...) (from the "cleanup" module from the file "cleanup.jl"), and it calls the underlying generic function (represent(...) from the "rpsr" module in "rpsr.jl"), which exhaustively searches the formula database for a "best" product-sum representation ("PSR"). The rpsr.represent(...) function is also used by the first stage, but with a different merit function generator.

  * If the second stage doesn't succeed to generate a "patched" formula with no "digit disparity", the algorithm progresses to the third and last stage, in which a second cleanup algorithm is attempted. This algorithm uses the same merit function as used in the second stage, but it only searches over sum or difference representations via adding or subtracting small numbers (and which therefore generate relatively small changes in the digit distogram of the formula). Because of the different form of the change in the formula, this search is currently not done by rpsr.represent(...) but instead has code which is structured similarly.
